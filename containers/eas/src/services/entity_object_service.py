"""Entity Object Interface."""

import logging

import jwt
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.serialization import load_pem_public_key

from .abstract_attribute_service import AbstractAttributeService
from .abstract_entity_service import AbstractEntityService
from ..eas_config import EASConfig
from ..errors import (
    AttributeExistsError,
    AuthorizationError,
    ConfigurationError,
    EasRequestError,
)
from ..server_timing import Timing
from ..util.jwt.jwt_utilities import exp_env_to_time

logger = logging.getLogger(__name__)
eas_config = EASConfig.get_instance()


EAS_PRIVATE_KEY = eas_config.get_item("EAS_PRIVATE_KEY").encode()


class EntityObjectService(object):
    """This class manages the entity object construction processes."""

    def __init__(
        self,
        entity_service: AbstractEntityService,
        attribute_service: AbstractAttributeService,
    ) -> None:
        """Construct an instance of EntityObjectService."""
        self.eas_config = EASConfig.get_instance()
        self.__entity_service: AbstractEntityService = entity_service
        self.__attribute_service: AbstractAttributeService = attribute_service
        self.__eas_private_key = EAS_PRIVATE_KEY

        # Create a default attribute for use later.
        try:
            self.__attribute_service.create(
                {
                    "attribute": self.eas_config.get_item("DEFAULT_ATTRIBUTE_URL"),
                    "isDefault": True,
                }
            )
        except AttributeExistsError:
            logger.debug("default attribute already created.")

    @Timing.timer
    def generate(
        self,
        publicKey: str = None,
        signerPublicKey: str = None,
        userId: str = None,
        kas_certificate: str = None,
    ) -> dict:
        """Construct an entity object for a particular entity.

        :param string publicKey:  the publicKey is an ephemeral key generated by the client to secure the session.
        :param string userId: The user or entity who needs an entity object generated for authentication
        :return: entity object as jwt signed by EAS private key
        """
        Timing.start("entity_object_service")
        logger.debug(
            "userId: %s, pk: %s, signerPk:%s", userId, publicKey, signerPublicKey
        )
        if not publicKey:
            raise EasRequestError("No publicKey")
        if not userId:
            raise EasRequestError("No userId")

        entity_public_key_bytes = publicKey.encode("utf8")

        # Make sure public key is valid
        try:
            entity_public_key = load_pem_public_key(
                entity_public_key_bytes, backend=default_backend()
            )
        except ValueError as e:
            raise EasRequestError("Invalid or unsupported entity public key") from e

        logger.debug("With public key %s", entity_public_key)
        # Make sure signer public key is valid
        if signerPublicKey:
            signer_public_key_bytes = signerPublicKey.encode("utf8")
            try:
                signer_public_key = load_pem_public_key(
                    signer_public_key_bytes, backend=default_backend()
                )
            except ValueError as e:
                raise EasRequestError("Invalid or unsupported signer public key") from e

        logger.debug("Make EntityObject for userId = %s", userId)
        entity = self.__entity_service.retrieve(userId)
        logger.debug("Retrieved: %s", entity)

        if entity is None:
            raise AuthorizationError("Unauthorized")

        if entity["state"] == "inactive":
            raise AuthorizationError("Inactive entity")
        Timing.start("attributes")
        attributes = []
        for attribute_url in entity["attributes"]:
            logger.debug("Fetching attribute = %s", attribute_url)
            attrs = self.__attribute_service.retrieve_jwt(
                [attribute_url], kas_certificate=kas_certificate
            )
            if attrs:
                # The export attribute is already in JWT form
                logger.debug("Loading attribute = %s", attrs[0])
                attributes.append(attrs[0])
        Timing.stop("attributes")
        Timing.start("default_attribute")
        # add a default attribute object
        default_attributes = self.__attribute_service.retrieve_jwt(
            [self.eas_config.get_item("DEFAULT_ATTRIBUTE_URL")],
            kas_certificate=kas_certificate,
        )
        if len(default_attributes) > 0:
            # There should be only one, but if there are multiple use the first
            default_attribute = default_attributes[0]
            logger.debug("DEFAULT ATTRIBUTE = %s", default_attribute)
            attributes.append(default_attribute)
        else:
            raise ConfigurationError(
                "Default attribute not found. Comes from DEFAULT_ATTRIBUTE_URL env var or defaults.json"
            )
        Timing.stop("default_attribute")
        logger.debug("Attributes = %s", attributes)
        entity_object = {
            "userId": entity["userId"],
            "aliases": [],
            "attributes": attributes,
            "publicKey": publicKey,
        }

        if signerPublicKey:
            entity_object["signerPublicKey"] = signerPublicKey

        exp = exp_env_to_time(eas_config.get_item("EAS_ENTITY_EXPIRATION"))
        if exp:
            entity_object["exp"] = exp

        entity_object_signed = jwt.encode(
            entity_object, self.__eas_private_key, algorithm="RS256"
        )

        entity_object["cert"] = entity_object_signed.decode("utf-8")
        Timing.stop("entity_object_service")
        return entity_object
