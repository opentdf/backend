# Tiltfile for development of OpenTDF backend
# reference https://docs.tilt.dev/api.html
# extensions https://github.com/tilt-dev/tilt-extensions
# helm remote usage https://github.com/tilt-dev/tilt-extensions/tree/master/helm_remote#additional-parameters

load("ext://helm_remote", "helm_remote")
load("ext://helm_resource", "helm_resource", "helm_repo")
load("ext://secret", "secret_from_dict", "secret_yaml_generic")
load("ext://min_tilt_version", "min_tilt_version")

min_tilt_version("0.30")

ALPINE_VERSION = os.environ.get("ALPINE_VERSION", "3.15")
PY_VERSION = os.environ.get("PY_VERSION", "3.10")
KEYCLOAK_BASE_VERSION = str(
    local('cut -d- -f1 < "{}"'.format("containers/keycloak-protocol-mapper/VERSION"))
).strip()

CONTAINER_REGISTRY = os.environ.get("CONTAINER_REGISTRY", "ghcr.io")
POSTGRES_PASSWORD = "myPostgresPassword"
OIDC_CLIENT_SECRET = "myclientsecret"
opaPolicyPullSecret = os.environ.get("CR_PAT")


def from_dotenv(path, key):
    # Read a variable from a `.env` file
    return str(local('. "{}" && echo "${}"'.format(path, key))).strip()


config.define_string_list("to-run", args=True)
config.define_string_list("to-edit")
cfg = config.parse()

to_edit = cfg.get("to-edit", [])

groups = {
    "integration-test": [
        "opentdf-xtest"
    ],
}

resources = []

isIntegrationTest = False
isPKItest = False

for arg in cfg.get("to-run", []):
    if arg == "integration-test":
        isIntegrationTest = True
    if arg in groups:
        resources += groups[arg]
    else:
        if arg == "pki-test":
            isPKItest = True
        # also support specifying individual services instead of groups, e.g. `tilt up a b d`
        resources.append(arg)

config.set_enabled_resources(resources)

#    db    db d888888b d88888b .d8888. d888888b
#    `8b  d8' `~~88~~' 88'     88'  YP `~~88~~'
#     `8bd8'     88    88ooooo `8bo.      88
#     .dPYb.     88    88~~~~~   `Y8b.    88
#    .8P  Y8.    88    88.     db   8D    88
#    YP    YP    YP    Y88888P `8888Y'    YP



docker_build(
    "opentdf/tests-clients",
    context="./",
    dockerfile="./tests/containers/clients/Dockerfile",
    # todo: (PLAT-1650) Force to x86 mode until we have a python built in arch64
    platform="linux/amd64",
)

# We re-run the bootstrapper here, with additive values specific to the integration tests
# Because Tilt Must Do Things Its Own Non-Normative Way, we must rebuild the bootstrap
# image again here, so Tilt knows about it.
# TODO we really should use a local image registry, explicit SHA tags, and stop relying on Tilt's
# slightly fragile image caching automagic - it obscures things and breaks more often than it helps.
docker_build(
    CONTAINER_REGISTRY + "/opentdf/keycloak-bootstrap",
    "./containers/keycloak-bootstrap",
    build_args={
        "CONTAINER_REGISTRY": CONTAINER_REGISTRY,
    },
)

# Possibly The Stupidest Thing About Tilt is that despite sitting *directly on top* of the K8S
# control plane, which would allow it to inspect, interrogate, and observe literally every workload
# in the cluster, it is singularly unable to do anything with a resource it didn't actually create.
# Sits on top of one of the most powerful workload management APIs in human history, says, "nope can't use it,
# not mine, can't trust it."
# So, we have to do nonsense like this, where we shell out to run a single, basic `kubectl` command to check a YAML propery.
# This will wait for a named K8S job (that we know exists, and K8S knows exists, but Tilt doesn't) to have a success status,
# before continuing.
local(["tests/integration/wait-for-ready.sh", "job/keycloak-bootstrap", "15m", "default"])

k8s_yaml(
    helm(
        "charts/keycloak_bootstrap",
        "xtest-keycloak-bootstrap",
        values=["./tests/integration/backend-keycloak-bootstrap-values.xtest.yaml"],
        set=[
            "secrets.oidcClientSecret=%s" % OIDC_CLIENT_SECRET,
            "image.name=" + CONTAINER_REGISTRY + "/opentdf/keycloak-bootstrap"
        ]
    )
)

# TODO why is this needed? Just to convince Tilt that something is there, because it can't just check
# the K8S control plane like everyone else?
k8s_resource(
    "xtest-keycloak-bootstrap",
    labels="xtest"
)

k8s_yaml("tests/integration/xtest.yaml")

k8s_resource(
    "opentdf-xtest",
    resource_deps=["xtest-keycloak-bootstrap"],
    labels="xtest"
)

if isPKItest:
    # TODO PKI tests involve only clients, Ingress and Keycloak - they are not backend tests, they are frontend tests,
    # and we should move them out of this repo if we keep them at all.
    #
    # PKI tests involve local clients using mTLS to go thru the cluster Ingress, and so we must port-forward
    # We cannot use `tilt`'s native `port_forward` functionality because tilt will not "see" any resources it didn't create
    # even if they're sitting right there in the cluster. And, as elsewhere, Tilt being both limited and controlling means
    # we have to work around it.
    local_resource("kubectl-portforward-https", serve_cmd="kubectl port-forward service/ingress-nginx-controller 4567:443")
    # Why do we have to port-forward TWICE? We really shouldn't need to, BUT the PKI tests assume clients auth with Keycloak
    # via OIDC on 4567, and contact KAS via 65432 - there should be no particular reason why we can't use the same one for both
    local_resource("kubectl-portforward-http", serve_cmd="kubectl port-forward service/ingress-nginx-controller 65432:80")
    local_resource(
        "pki-test",
        "python3 tests/integration/pki-test/client_pki_test.py",
        resource_deps=["xtest-keycloak-bootstrap", "kubectl-portforward-https", "kubectl-portforward-http"],
    )

